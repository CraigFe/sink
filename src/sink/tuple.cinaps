(* -*- mode: tuareg -*- *)

let alpha i = Char.chr (i + 96)

type component = { fmap : string; proj : string }

let component = function
  | 1 -> { fmap = "first "; proj = "p1" }
  | 2 -> { fmap = "second"; proj = "p2" }
  | 3 -> { fmap = "third "; proj = "p3" }
  | 4 -> { fmap = "fourth"; proj = "p4" }
  | 5 -> { fmap = "fifth "; proj = "p5" }
  | _ -> assert false

let print_tuple ppf n =
  for i = 1 to n - 1 do
    Format.fprintf ppf "'%c * " (alpha i)
  done;
  Format.fprintf ppf "'%c" (alpha n)

let print_const ?(suffixes = []) () ppf n =
  let suffix i =
    match List.assoc_opt i suffixes with Some s -> s | None -> ""
  in
  Format.fprintf ppf "(";
  for i = 1 to n - 1 do
    Format.fprintf ppf "'%c%s, " (alpha i) (suffix i)
  done;
  Format.fprintf ppf "'%c%s) t" (alpha n) (suffix n)

let print_projections ppf n =
  Format.fprintf ppf "  (** Projecting each component from the tuple: *)\n";
  for i = 1 to n do
    Format.fprintf ppf "  val %s : %a -> '%c\n" (component i).proj
      (print_const ()) n (alpha i)
  done

let print_maps ppf n =
  Format.fprintf ppf "  (** Functor instances on each of the components: *)\n";
  for i = 1 to n do
    Format.fprintf ppf "  val %s : ('%c1 -> '%c2) -> %a -> %a\n"
      (component i).fmap (alpha i) (alpha i)
      (print_const ~suffixes:[ (i, "1") ] ())
      n
      (print_const ~suffixes:[ (i, "2") ] ())
      n
  done

let print_module n =
  Format.printf "\nmodule T%d : sig  end = struct\n" n;

  Format.printf "  type %a = %a [@@implements Eq.S]\n" (print_const ()) n
    print_tuple n;

  Format.printf "\n%a" print_projections n;
  Format.printf "\n%a" print_maps n;
  Format.printf "end\n"
